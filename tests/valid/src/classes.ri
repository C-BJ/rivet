class A {
    mut i: int32 = 10;
}

class B : A {
    c: int32;

    func set_i(mut self, i: int32) {
        self.i = i;
    }

    func set_base_i(mut self, i: int32) {
        base.i = i;
    }
}

test "inheritance: using inherited fields" {
    b := B(i: 99);
    @assert(b.i == 99);

    b2 := B();
    @assert(b2.i == 10);

    b3 := B(1, 2);
    @assert(b3.i == 1);
    @assert(b3.c == 2);
}

test "inheritance: using `base`" {
    mut b2 := B();
    @assert(b2.i == 10);

    b2.set_i(5);
    @assert(b2.i == 5);

    b2.set_base_i(8);
    @assert(b2.i == 8);
}

test "inheritance: downcast" {
    b := B(c: 5);

    a := @cast(A, b);
    @assert(a.i == 10);

    b2 := @cast(B, a);
    @assert(b2.c == 5);
}

test "inheritance: typeswitch" {
    b := B(c: 5);
    a := @cast(A, b);
    @assert(switch a is {
        B => true,
        else => false
    });
}

class Animal {
    public func speak(self) string {
        return "~ Animal.speaks() ~";
    }
}

class Dog : Animal {
    #[override]
    public func speak(self) string {
        return "woof";
    }
}

class Cat : Animal {
    #[override]
    public func speak(self) string {
        return "meow";
    }
}

class NonAnimal : Animal { }

test "inheritance: virtual methods and `#[override]`" {
    non_animal := NonAnimal();
    @assert(non_animal.speak() == "~ Animal.speaks() ~");

    dog := Dog();
    @assert(dog.speak() == "woof");

    cat := Cat();
    @assert(cat.speak() == "meow");
}
