// Copyright (C) 2022 The Rivet Developers. All rights reserved.
// Use of this source code is governed by an MIT license that can
// be found in the LICENSE file.

import "std/env";
import "std/strings";
import "std/console";
import "std/fs/path";
import "std/process";

import "../prefs";
import "../token";
import "../utils";

public var mut reports = ReportTable();

[inline]
public func total_errors() usize {
    return reports.errors;
}

[inline]
public func total_warns() usize {
    return reports.warns;
}

[boxed]
public struct ReportTable {
    public mut prefs: prefs.Prefs;
    public mut errors: usize;
    public mut warns: usize;
}

public enum ReportKind as uint8 {
    Error,
    Warn,
    Note,
    Help
}

[boxed]
public struct ReportExtra {
    public kind: ReportKind;
    public msg: string;
}

[inline]
public func error(msg: string, pos: token.Pos) Report {
    return Report(.Error, pos, msg);
}

[inline]
public func warn(msg: string, pos: token.Pos) Report {
    return Report(.Warn, pos, msg);
}

[boxed]
public struct Report {
    public kind: ReportKind;
    public pos: token.Pos;
    public msg: string;
    public mut extras: []ReportExtra;

    [inline]
    public func add_note(mut self, msg: string) {
        self.extras.push(ReportExtra(.Note, msg));
    }

    [inline]
    public func add_help(mut self, msg: string) {
        self.extras.push(ReportExtra(.Help, msg));
    }

    public func emit(self) {
        console.eprintln(
            utils.bold("{}: {} {}"), self.pos.to_report_string(), if self.kind == .Error {
                utils.red("error:")
            } else {
                utils.yellow("warning:")
            }, self.msg
        );
        if self.pos.is_multiline {
            formatted_multi_line(self.pos);
        } else {
            formatted_single_line(self.pos);
        }
        if self.kind == .Error {
            reports.errors += 1;
        } else {
            reports.warns += 1;
        }
        for extra in self.extras {
            start := utils.bold("      {} {}".fmt(utils.blue("="), if extra.kind == .Note {
                utils.cyan("note:")
            } else {
                "help:"
            }));
            console.eprintln("{} {}", start, extra.msg);
        }
    }
}

func formatted_multi_line(pos: token.Pos) {
    if lines := utils.source_cache.find_lines_between(pos.file, pos.line, pos.end_line + 1) {
        mut ellipsis := false;
        max := if lines.len % 2 == 0 { lines.len / 2 } else { 4 };
        for line_nr, line in lines {
            if line_nr <= max or line_nr > line_nr - max {
                console.eprintln(
                    "{} {} {}", utils.bold(utils.blue("{:5}".fmt(line_nr + pos.line + 1))),
                    utils.bold(utils.blue("|")), line.replace("\t", "    ")
                );
            } else if !ellipsis {
                ellipsis = true;
                console.eprintln(utils.bold(utils.blue("  ... |")));
            }
        }
    }
}

func formatted_single_line(pos: token.Pos) {
    if line := utils.source_cache.find_line(pos.file, pos.line) {
        console.eprintln(
            "{} {} {}", utils.bold(utils.blue("{:5}".fmt(pos.line + 1))),
            utils.bold(utils.blue("|")), line.replace("\t", "    ")
        );
        start_column := utils.max(0, utils.min(pos.col, line.len));
        end_column := utils.max(0, utils.min(pos.col + utils.max(0, pos.len), line.len));
        mut sb := strings.Builder.new(line.len);
        mut i: usize := 0;
        while i < start_column {
            b := line[i];
            if b.is_space() {
                sb.write_byte(b);
                i += 1;
            } else {
                char_len := b.len_utf8();
                sb.write_string(" ".repeat(line[i..i + char_len].runes_count()));
                i += char_len;
            }
        }
        sb.write_string(utils.bold(utils.blue("^")));
        if pos.len > 1 {
            sb.write_string(
                utils.bold(
                    utils.blue("-".repeat(line[start_column..end_column].runes_count() - 1))
                )
            );
        }
        console.eprintln("      {} {}", utils.bold(utils.blue("|")), sb.to_string());
    }
}
