// simple comment

/*
* multi-comment
*/

extern pkg core;
extern pkg std;

extern "C" {
    fn exit(status: i32) c_void;
    fn abort() c_void;
}

extern "C" fn abs(a: i32) i32;

/// A simple module for doc-comments.
///
/// Other new line in doc-comment. More text, simple =D.
mod simple { }

pub mod simple2 {
    pub mod inner_mod {
        pub mod pub_inner_mod { }
    }

    mod snacks { }
}

extend u8 {
    pub fn to_str() str { return ""; }
}

extend pkg::custom_mod::CustomType {
    pub fn custom_fn() void { }
}

[unsafe]
pub fn pub_basic_fn(alpha: i32, arr: [i32; 5], slice: [i32]) void { }

[inline]
fn basic_fn(return_none: bool) ?i32 {
    return if (return_none) none else 5;
}

[unsafe; abstract; virtual] // <- attributes
fn def_arg(a: i32 = 10, tuple: (bool, void, u8)) void { }

fn result() !i32 { }

[unsafe]
fn simple() !void {
    try run(player: Player{
        name: "StunxFS",
        rol: .Sheriff
    });

    expr_stmt({
        // block expression
        call1();
        call2();
        2 / 5
    });

    { // block statement
        expr_stmt(
            {
                // block expression
                call1();
                call2();
                2 / 5
            },
            {
                // block expr
                call1();
                call2();
            },
            if (true) { // if expr
                install_app();
                .Installed
            } else {
                panic!("error");
            },
            match (xyz) { // match expr
                5 => get_windows_size(),
                8 => get_named_arg(),
                else => get_anarky()
            },
            array: [1, 2, 3, 4, 5, 6, 7, 8],
            slice: [1, 2, 3, 4, 5, 6][0..4],
            tuple: (1, 2, 3, 4, 5, 6, 7, 8)
        );
    }

    // if stmt
    if (true) {
        call9();
    } elif (false) {
        call10();
    } else {
        call11();
    }

    // match stmt
    match (555) {
        555 => println("555"),
        777 => println("777"),
        888, 999 => println("888 or 999"),
        else => println("finch")
    }

    // typematch
    match (union_value) is {
        str => println("str"),
        i32 => println("i32"),
        bool => {
            // block expr
            loop { println("simple block expr"); }
        },
        else => println("unknown type")
    }

    // let mut x = 1;
    while (x < 5) {
        x++;
    }

    loop {
        x++;
        if (x < 5) {
            call12();
        }
    }
}

mod real {
    pub fn scrash() void {
        return;
    }

    pub mod sis {
        fn inner(a: &[i32], mut b: [u8; 4]) void { }
    }

    fn x() !i32 { }

    fn z(a: *i32, b: ***i32) ?bool {}

    fn arrays() [i32; 5] { }

    fn slices() &[i32] { }
}

/// doc-comment
fn main() void {
    // Unlike `while` and `loop`, `for` is only valid with values
    // that implement the `Iterator` trait.
    for (x in [1, 2, 3, 4]) {
        // ...
    }

    // The `for` is just a shorthand way of writing the following:
    // let _T0 = [1, 2, 3, 4].iter();
    // let _T1 = _T0.next();
    while (_T1 != none) {
        // ...
        // _T1 = _T0.next();
    }
}
