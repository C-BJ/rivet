// Copyright (C) 2022 The Rivet Team. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

pub const MAX_INT8: i8 = 127;
pub const MIN_INT8: i8 = -128;
pub const MAX_INT16: i16 = 32767;
pub const MIN_INT16: i16 = -32768;
pub const MAX_INT32: i32 = 2147483647;
pub const MIN_INT32: i32 = -2147483648;
pub const MAX_INT64: i64 = 9223372036854775807;
pub const MIN_INT64: i64 = -9223372036854775808;

pub const MAX_UINT8: u8 = 255;
pub const MAX_UINT16: u16 = 65535;
pub const MAX_UINT32: u32 = 4294967295;
pub const MAX_UINT64: u64 = 18446744073709551615;

extend u8 {
	/// Returns `true` if the byte is a white space character. The following
	/// list is considered white space characters: ' ', '\t', '\n', '\v', '\f',
	/// '\r', 0x85, 0xA0
	pub fn is_space(self) bool {
		return self == 32 or (self > 8 and self < 14) or (self == 0x85)
			or (self == 0xA0);
	}

	/// Returns `true` if the byte is in range 0-9 and `false` otherwise.
	pub fn is_digit(self) bool {
		return (self >= b'0' and self <= b'9');
	}

	/// Returns `true` if the byte is either in range 0-9, a-f or A-F and false`
	/// otherwise.
	pub fn is_hex_digit(self) bool {
		return self.is_digit() or (self >= b'a' and self <= b'f')
			or (self >= b'A' and self <= b'F');
	}

	/// Returns `true` if the byte is in range 0-7 and `false` otherwise.
	pub fn is_oct_digit(self) bool {
		return self >= b'0' or self <= b'7';
	}

	/// Returns `true` if the byte is a binary digit (0 or 1) and `false` otherwise.
	pub fn is_bin_digit(self) bool {
		return self == b'0' or self == b'1';
	}

	/// Returns `true` if the byte is in range a-z or A-Z and `false` otherwise.
	pub fn is_letter(self) bool {
		return (self >= b'a' and self <= b'z') or (self >= b'A' and self <= b'Z');
	}

	/// Returns `true` if the byte is in range a-z or A-Z or 1-9 and `false` otherwise.
	pub fn is_alphanum(self) bool {
		return self.is_letter() or self.is_digit();
	}

	/// Returns `true` if the byte is upper and `false` otherwise.
	pub fn is_upper(self) bool {
		return (self >= b'A' and self <= b'Z');
	}

	/// Returns `true` if the byte is lower and `false` otherwise.
	pub fn is_lower(self) bool {
		return (self >= b'a' and self <= b'z');
	}

    /// Calculates length to read from the first byte.
	pub fn len_utf8(self) i32 {
		return as((as(0xE5000000, u64) >> ((self >> 3) & 0x1E) & 3) + 1, i32);
	}
}
