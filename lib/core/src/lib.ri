// Copyright (C) 2022 The Rivet Team. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

/// The C standard library bindings.
mod stdc;

import pkg::stdc: stdio, stdlib;
import pkg::backtrace;

extern "C" {
    fn _R9init_argsZ(__argc: i32, __argv: *const *const u8);
    fn _R9drop_argsZ();

    fn _R12init_staticsZ();
    // TODO(StunxFS): fn _R12drop_staticsZ();
}

pub errtype Error;

pub static ARGS: [str] = [""][..];

#[used]
fn rivet_init(__argc: i32, __argv: *const *const u8, pkg_main: fn()) {
    unsafe {
        _R9init_argsZ(__argc, __argv);
        _R12init_staticsZ();
        pkg_main();
        // TODO(StunxFS): _R12drop_staticsZ();
        _R9drop_argsZ();
    }
}

#[used]
struct _error {
    errtype_name: str;
    msg: str;
    tag: u8; // max: 255

    #[used]
    fn print(&self) {
        eprint("[error] ");
        if (self.msg.size == 0) {
            eprintln(self.errtype_name);
        } else {
            eprint(self.errtype_name);
            eprint(": ");
            eprintln(self.msg);
        }
        backtrace::print(2);
        exit(1);
    }
}

/// Prints a message to stdout. Unlike `println` stdout is not automatically
/// flushed.
pub fn print(s: str) {
    unsafe {
        write_buf_to_fd(1, s.ptr, s.size);
    }
}

/// Prints a message with a line end to stdout. stdout is flushed.
pub fn println(s: str = "") {
    unsafe {
        writeln_to_fd(1, s);
    }
}

/// Prints a message to stderr. Both stderr and stdout are flushed.
pub fn eprint(s: str) {
    unsafe {
        stdio::fflush(stdio::stdout);
        stdio::fflush(stdio::stderr);
        write_buf_to_fd(2, s.ptr, s.size);
        stdio::fflush(stdio::stderr);
    }
}

/// Prints a message with a line end, to stderr. Both stderr and stdout are
/// flushed.
pub fn eprintln(s: str = "") {
    unsafe {
        stdio::fflush(stdio::stdout);
        stdio::fflush(stdio::stderr);
        writeln_to_fd(2, s);
        stdio::fflush(stdio::stderr);
    }
}

#[used]
fn assert(cond: bool, msg: str) {
    if (!cond) {
        eprint("panic: assertion failed: ");
        eprintln(msg);
        backtrace::print(2);
        exit(1);
    }
}

pub fn panic(s: str = "") no_return {
    eprint("panic: ");
    eprintln(s);
    backtrace::print(1);
    exit(1);
}

#[used]
fn panic_if(cond: bool, msg: str) {
    if (cond) {
        eprint("panic: ");
        eprintln(msg);
        backtrace::print(2);
        exit(1);
    }
}

/// Terminates execution immediately and returns exit `code` to the shell.
pub fn exit(code: i32 = 0) no_return {
    unsafe {
        // TODO(StunxFS): _R12drop_staticsZ();
        _R9drop_argsZ();
        stdlib::exit(code);
    }
}

pub fn abort() no_return {
    unsafe {
        // TODO(StunxFS): _R12drop_staticsZ();
        _R9drop_argsZ();
        stdlib::abort();
    }
}

unsafe fn write_buf_to_fd(fd: i32, buf_: *const u8, buf_len: usize) {
    let mut buf = buf_;
    let mut remaining_bytes = buf_len;
    while (remaining_bytes > 0) {
        unsafe {
            let x = stdio::write(fd, buf, remaining_bytes);
            buf += x;
            remaining_bytes -= as(x, usize);
        }
    }
}

unsafe fn writeln_to_fd(fd: i32, s: str) {
    unsafe {
        write_buf_to_fd(fd, s.ptr, s.size);
        write_buf_to_fd(fd, c"\n", 1);
    }
}
