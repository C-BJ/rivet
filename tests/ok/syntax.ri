// simple comment

/*
* multi-comment
*/

extern pkg core;
extern pkg std;

const MAX_SIZE: i32 = 10;
const MIN_SIZE: i32 = 1;

static GLOBAL_VALUE: i32 = 10;
static mut UNSAFE_GLOBAL_VALUE: i32 = 5;

type Integer32 = i32;
pub type WideChar = u16;
pub type WideStr = *u16;

pub(pkg) type Byte = u8;
pub type Int = i32;

errtype RuntimeError;
pub errtype FileNotFoundError;

fn open(path: str) !str {
    $if (_LINUX_) {
        if (!exists(path)) {
            raise FileNotFoundError();
        }
        return path;
    }
    raise RuntimeError("unsupported OS for `open`");
}

enum Service {
    VIP,
    Fast,
    Unique,
    Small,
    Free
}

struct Account {
    pub mut name: str;
    pub id: i32; // unique ID
    pub mut password: str;
    pub mut is_active: bool;

    /// Custom services. A private field.
    mut services: [Service; 3] = [Service::VIP, .Small, .Unique];

    #[inline]
    pub fn new(name: str, password: str) Self {
        return Self{
            name: name,
            id: generate_unique_id(),
            password: password
        };
    }

    other_field: bool;

    fn method(self) void {
        loop {
            if (1 >= 3) {
                break;
            }
            continue;
        }
    }

    fn method2(&self) void { }

    fn method3(mut &self) void { }

    fn associated_function() void {
    L1:
        trace!("garrotero");
        unsafe { goto L1; }
    }

    ~self {
        // struct destructor
        trace!("~Account() called");
    }
}

trait Printable {
    fn to_str() str;
}

trait Writable {
	fn write(buf: [u8]) !?i32;
	fn write_to(pos: u64, buf: [u8]) !?i32;
}

trait Widget {
    fn id() str;

    fn id_and_name() str {
        return self.id();
    }
}

fn optional() ?i32 {
    return none;
}

fn error() !void {
    raise RuntimeError("simple error =D");
}

test "Test body with cool name =D!" {
    trace!("inside test");
    assert!(2 >= 5);

    let mut x = optional() orelse {
        5
    };
    assert!(x == 5);

    x = 10;
    assert!(x == 10);

    x += 10;
    assert!(x == 20);

    let (a, b, c) = (1, 2, 3);
    assert!(a == 1 and b == 2 and c == 3);

    error() catch {
        trace!("error catched");
    };

    error() catch |err| {
        assert!(err is RuntimeError);
        assert!(err.msg.len == 15);
    };
}

struct EmptyStruct { }

union Expr {
    IntegerLiteral, StructLiteral, BinaryExpr
}

#[no_tag]
union LikeC {
    f32, i32
}

union Object {
    str, i64;

    fn to_str() str {
        if (self is str) {
            return cast(self, str);
        }
        return "<i64-value>";
    }
}

enum ReportLevel {
    Low,
    High
}

enum NPCRol {
    Enemy,
    Friend,
    Helper,
    Bot,
    Police;

    pub fn to_str() str {
        if (self == .Enemy) {
            return "<Enemy>";
        }
        return "<Friend =D>";
    }
}

#[if (DEFINE_EXIT_FUNCS)]
extern "C" {
    fn exit(status: i32) c_void;
    fn abort() c_void;
}

#[if (_LINUX_ and _AMD64_ and _x64_ and _LITTLE_ENDIAN_ and DEFINE_ABS)]
extern "C" fn abs(a: i32) i32;

/// A simple module for doc-comments.
///
/// Other new line in doc-comment. More text, simple =D.
mod simple { }

pub mod simple2 {
    pub mod inner_mod {
        pub mod pub_inner_mod { }
    }

    mod snacks { }
}

extend u8 {
    pub fn to_str() str { return ""; }
}

#[if (EXTEND_CUSTOM_TYPE)]
extend pkg::custom_mod::CustomType {
    pub fn custom_fn() void { }
}

pub fn pub_basic_fn(alpha: i32, arr: [i32; 5], slice: [i32]) void { }

#[inline]
fn basic_fn(return_none: bool) ?i32 {
    return if (return_none) none else 5;
}

#[abstract; virtual] // <- attributes
unsafe fn def_arg(a: i32 = 10, tuple: (bool, void, u8)) void { }

fn result() !i32 { }

fn simple() !void {
    call_unsafe(unsafe {
        trace!("inside unsafe!");
        x()
    });
    unsafe {
        x();
    }

    go run_thread();

    try run(player: Player{
        name: "StunxFS",
        rol: .Sheriff
    });

    expr_stmt({
        // block expression
        call1();
        call2();
        2 / 5
    });

    { // block statement
        expr_stmt(
            {
                // block expression
                call1();
                call2();
                2 / 5
            },
            {
                // block expr
                call1();
                call2();
            },
            if (true) { // if expr
                install_app();
                .Installed
            } else {
                panic!("error");
            },
            match (xyz) { // match expr
                5 => get_windows_size(),
                8 => get_named_arg(),
                else => get_anarky()
            },
            array: [1, 2, 3, 4, 5, 6, 7, 8],
            slice: [1, 2, 3, 4, 5, 6][0..4],
            tuple: (1, 2, 3, 4, 5, 6, 7, 8)
        );
    }

    // if stmt
    if (true) {
        call9();
    } elif (false) {
        call10();
    } else {
        call11();
    }

    // match stmt
    match (555) {
        555 => println("555"),
        777 => println("777"),
        888, 999 => println("888 or 999"),
        else => println("finch")
    }

    // typematch
    match (union_value) is {
        str => println("str"),
        i32 => println("i32"),
        bool => {
            // block expr
            loop { println("simple block expr"); }
        },
        else => println("unknown type")
    }

    // let mut x = 1;
    while (x < 5) {
        x++;
    }

    loop {
        x++;
        if (x < 5) {
            call12();
        }
    }
}

mod real {
    pub fn scrash() void { return; }

    pub mod sis {
        fn inner(a: &[i32], mut b: [u8; 4]) void { }
    }

    fn x() !i32 { }

    fn z(a: *i32, b: ***i32) ?bool {}

    fn arrays() [i32; 5] { }

    fn slices() &[i32] { }
}

fn comptime() void {
    print_target_info($_OS_, $_ARCH_, $_ENDIAN_, $_BITS_, $_BACKEND_);
    print_info($_FILE_, $_FUNCTION_, $_LINE_, $_COLUMN_);
    $if (_LINUX_) {
        compile_warn!("comptime works!");
    } $else {
        compile_warn!("comptime doesn't works =(");
    }
    $match ($_OS_) {
        _LINUX_ => trace!("Running on Linux"),
        else => trace!("unknown OS")
    }
}

/// doc-comment
fn main() void {
    // Unlike `while` and `loop`, `for` is only valid with values
    // that implement the `Iterator` trait.
    for (x in [1, 2, 3, 4]) {
        // ...
    }

    // The `for` is just a shorthand way of writing the following:
    let _T0 = [1, 2, 3, 4].iter();
    let _T1 = _T0.next();
    while (_T1 != none) {
        // ...
        _T1 = _T0.next();
    }

    let map: Map = Map::new([("Key", 5)]);
    for ((key, mut &value) in map) {
        assert!(key == "Key" and value.* == 5);
    }
}
