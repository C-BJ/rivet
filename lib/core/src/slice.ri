// Copyright (C) 2022 The Rivet Team. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

import pkg::stdc: string;

#[used]
struct _slice {
    ptr: *mut void;
    elem_size: usize;
    len: usize;

    #[used]
    fn get(&self, idx: usize) *mut void {
        if (idx >= self.len) {
            panic("slice index out of range");
        }
        return unsafe { as(*mut u8, self.ptr) + idx * self.elem_size };
    }

    #[used]
    unsafe fn raw_get(&self, idx: usize) *mut void {
        return unsafe { as(*mut u8, self.ptr) + idx * self.elem_size };
    }

    #[used]
    fn set(&self, idx: usize, val: *const void) {
        if (idx >= self.len) {
            panic("slice index out of range");
        }
        _ = unsafe {
            string::memcpy(as(*mut u8, self.ptr) + self.elem_size * idx, val, self.elem_size)
        };
    }

    #[used]
    fn slice(&self, start: usize, end: usize) _slice {
        if (start > end or end > self.len) {
            panic("slice index out of range");
        }
        let len = end - start;
        if (len == self.len) {
            return self.*;
        }
        return _slice{
            ptr: unsafe { as(*mut u8, self.ptr) + (start * self.elem_size) },
            elem_size: self.elem_size,
            len: len
        };
    }

    #[used]
    fn slice_from(&self, start: usize) _slice {
        return self.slice(start, self.len);
    }

    #[used]
    fn eq(&self, other: &_slice) bool {
        if (self.len != other.len) {
            return false;
        }
        return unsafe { string::memcmp(self.ptr, other.ptr, self.len) == 0 };
    }

    #[used]
    fn ne(&self, other: &_slice) bool { return !self.eq(other); }
}
