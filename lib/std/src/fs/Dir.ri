// Copyright (C) 2022 The Rivet Developers. All rights reserved.
// Use of this source code is governed by an MIT license that can
// be found in the LICENSE file.

import "c";
import "c/libc";

import "./path";

pub struct Dir {
    pub fn make(path_: string, mode: usize = 511 /* 0o777 */) ! {
        if path_ == "." {
            return;
        }
        let rpath = path.resolve(path_).!;
        if unsafe { libc.mkdir(rpath.ptr, mode) } == -1 {
            return Error("cannot make directory `{}`: {}".fmt(path_, c.errno_msg()));
        }
    }

    pub fn remove(dir: string) ! {
        let rpath = path.resolve(dir).!;
        if unsafe { libc.rmdir(rpath.ptr) == -1 } {
            return c.last_errno_error();
            return Error("cannot remove directory `{}`: {}".fmt(dir, c.errno_msg()));
        }
    }

    pub fn walk(path: string) ![string] {
        unsafe {
            if let dir = libc.opendir(path.ptr) {
                let mut res: [string] = [];
                while let ent = libc.readdir(dir) {
                    let bptr = @addr_of(ent.*.d_name[0]);
                    if (bptr[0] == 0 or (bptr[0] == b'.' and bptr[1] == 0)
                        or (bptr[0] == b'.' and bptr[1] == b'.' and bptr[2] == 0)) {
                        continue;
                    }
                    res.push(string.from_raw(bptr).clone());
                }
                _ = libc.closedir(dir);
                return res;
            }
        }
        return Error("walk: couldn't open '{}'".fmt(path));
    }
}
