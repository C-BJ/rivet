// Copyright (C) 2022 The Rivet Team. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

using pkg::stdc;
using pkg::traits::ToString;

#[used]
struct _str {
    ptr: *const u8;
    pub len: usize;
}

extend str {
    pub unsafe fn from_cstr(cstr: *const u8) str {
        let len = unsafe { stdc::strlen(cstr) };
        return _str{
            ptr: cstr,
            len: len
        };
    }

    pub unsafe fn from_cstr_with_len(cstr: *const u8, len: usize) str {
        return _str{
            ptr: cstr,
            len: len
        };
    }

    fn ==(&self, rhs: &Self) bool {
        if (self.ptr == none) {
            panic("str::eq: none string");
        }
        if (self.len != rhs.len) {
            return false;
        }
        if (self.len > 0) {
            let last_idx = self.len - 1;
            if (unsafe { self.ptr[last_idx] != rhs.ptr[last_idx] }) {
                return false;
            }
        }
        return mem::cmp(self.ptr, rhs.ptr, rhs.len) == 0;
    }

    fn !=(&self, rhs: &Self) bool { return !self.==(rhs); }

    fn <(&self, rhs: &Self) bool {
        for (i in 0..self.len) {
            if (i >= rhs.len or unsafe { self.ptr[i] > rhs.ptr[i] }) {
                return false;
            } elif (unsafe { self.ptr[i] < rhs.ptr[i] }) {
                return true;
            }
        }
        if (self.len < rhs.len) {
            return true;
        }
        return false;
    }

    fn >(&self, rhs: &Self) bool { return !self.<(rhs); }

    fn <=(&self, rhs: &Self) bool { return self.<(rhs) or self.==(rhs); }

    fn >=(&self, rhs: &Self) bool { return self.>(rhs) or self.==(rhs); }

    pub fn is_empty(&self) bool { return self.len == 0; }

    /// Returns the number of runes contained in `self`.
    pub fn runes_count(&self) usize { return cstr_runes_count(self.ptr, self.len); }

    pub fn as_bytes(&self) [u8] {
        return unsafe { _slice::from_array(as(*mut u8, self.ptr), sizeof!(u8), self.len) };
    }

    #[used]
    fn slice(&self, start: usize, end: usize) str {
        if (start > end or start > self.len or end > self.len) {
            panic("string slice index out of range");
        }
        let len = end - start;
        if (len == self.len) {
            return self.*;
        }
        let ptr = unsafe { self.ptr + start };
        return _str{
            ptr: ptr,
            len: len
        };
    }

    #[used]
    fn slice_from(&self, start: usize) str {
        return self.slice(start, self.len);
    }
}

extend str for ToString {
    fn to_string(&self) String { return String::from_str(self.*); }
}
