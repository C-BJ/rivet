// Copyright (C) 2022 The Rivet Developers. All rights reserved.
// Use of this source code is governed by an MIT license that can
// be found in the LICENSE file.

import "c/libc";

let empty_string: string = string(c"", 0, true);

pub class string : ToString, Hasher {
    pub ptr: *u8;
    pub len: usize;
    is_ref: bool;

    #[unsafe]
    pub fn from_raw(ptr: ?*u8, is_ref: bool = false) Self {
        if let safe_ptr = ptr {
            return unsafe {
                Self.from_raw_with_len(safe_ptr, libc.strlen(ptr), is_ref)
            };
        }
        return empty_string;
    }

    #[unsafe]
    pub fn from_raw_with_len(ptr: ?*u8, len: usize, is_ref: bool = false) Self {
        if len == 0 {
            return empty_string;
        }
        if let safe_ptr = ptr {
            return Self(safe_ptr, len, is_ref);
        }
        return empty_string;
    }

    pub fn from_byte(byte: u8) Self {
        let res = @as(*mut u8, internal_alloc(2));
        unsafe {
            res[0] = byte;
            res[1] = 0;
        }
        return Self(res, 1);
    }

    /// Returns a string with the bytes stored in `bytes`. If the length of
    /// `bytes` is 0, an empty string is returned instead.
    pub fn from_bytes(bytes: [u8]) Self {
        if bytes.len == 0 {
            return empty_string;
        }
        let res = @as(*mut u8, internal_alloc(bytes.len + 1));
        unsafe {
            mem_copy(res, @addr_of(bytes[0]), bytes.len);
            res[bytes.len] = 0;
        }
        return Self(res, bytes.len);
    }

    fn at(self, idx: usize) u8 {
        if idx >= self.len {
            process_panic("string index out of range (index: {}, len: {})", idx, self.len);
        }
        return unsafe { self.ptr[idx] };
    }

    pub fn repeat(self, count: usize) string {
        if count == 0 {
            return empty_string;
        } else if count == 1 {
            return self;
        }
        let len = self.len * count;
        let res = @as(*mut u8, internal_alloc(len));
        unsafe {
            let mut i: usize = 0;
            while i < count : i += 1 {
                let mut j: usize = 0;
                while j < self.len : j += 1 {
                    res[i * self.len + j] = self.ptr[j];
                }
            }
            res[len] = 0;
        }
        return Self(res, len);
    }

    pub fn concat(self, others: ...Self) Self {
        let mut sb = StringBuilder.from_string(self);
        for other in others {
            sb.write_string(other);
        }
        return sb.to_string();
    }

    /// Returns a string formatted with all the values passed.
    ///
    /// Each replacement position is marked with `{}`:
    ///
    /// `"x: {}".fmt(1) == "x: 1"`
    ///
    /// It is also possible to use a specific position within the replace position:
    ///
    /// `"x: {1} | {0}".fmt(1, 2) == "x: 2 | 1"`
    ///
    /// If no argument is passed, the string is returned unchanged.
    ///
    /// To escape `{` and `}`, `{{` and `}}` can be used, this does not apply if no
    /// argument is passed.
    ///
    /// If the replacement positions exceed the number of passed arguments, a panic
    /// occurs.
    pub fn fmt(self, args: ...ToString) Self {
        if args.len == 0 {
            return self;
        }
        return StringFormatter(self).fmt(args);
    }

    /// Returns the number of occurrences of `substr` in the string or -1 if no
    /// `substr` could be found.
    pub fn count(self, substr: string) usize {
        if self.len == 0 or substr.len == 0 {
            return 0;
        }
        if substr.len > self.len {
            return 0;
        }
        let mut n: usize = 0;
        if substr.len == 1 {
            for l in self.as_bytes() {
                if l == substr[0] {
                    n += 1;
                }
            }
            return n;
        }
        let mut i: usize = 0;
        while {
            i = self.index_after_of(substr, i) ?? return n;
            i += substr.len;
            n += 1;
        }
        return 0;
    }

    /// Returns the index of byte `b` if found in the string.
    pub fn index_of_byte(self, b: u8) ?usize {
        let mut i: usize = 0;
        while i < self.len : i += 1 {
            if unsafe { self.ptr[i] == b } {
                return i;
            }
        }
        return nil;
    }

    /// Returns the position of the first character of the input string.
    /// It will return `nil` if the input string can't be found.
    pub fn index_of(self, p: string) ?usize {
        if p.len > self.len or p.len == 0 {
            return nil;
        }
        let mut i: usize = 0;
        while i < self.len : i += 1 {
            let mut j: usize = 0;
            while j < p.len and unsafe { self.ptr[i + j] == p.ptr[j] } : j += 1 { }
            if j == p.len {
                return i;
            }
        }
        return nil;
    }

    /// Returns the position of the input string, starting search from `start` position.
    pub fn index_after_of(self, p: string, start: usize) ?usize {
        if p.len > self.len {
            return nil;
        }
        let mut strt = start;
        if start >= self.len {
            return nil;
        }
        let mut i = strt;
        while i < self.len : i += 1 {
            let mut j: usize = 0;
            let mut ii = i;
            while j < p.len and unsafe { self.ptr[ii] == p.ptr[j] } {
                j += 1;
                ii += 1;
            }
            if j == p.len {
                return i;
            }
        }
        return nil;
    }

    /// Linear search for the last index of `byte` inside a string.
    pub fn last_index_of_byte(self, byte: u8) ?usize {
        let mut i: usize = self.len;
        while i != 0 {
            i -= 1;
            if unsafe { self.ptr[i] == byte } {
                return i;
            }
        }
        return nil;
    }

    /// Returns the position of the last occurence of the input string.
    fn last_index_of(self, p: string) ?usize {
        if p.len > self.len or p.len == 0 {
            return nil;
        }
        let mut i: usize = self.len - p.len;
        while i >= 0 : i -= 1 {
            let mut j: usize = 0;
            while j < p.len and unsafe { self.ptr[i + j] == p.ptr[j] } : j += 1 { }
            if j == p.len {
                return i;
            }
        }
        return nil;
    }

    /// Returns the string found between `start` string and `end` string.
    pub fn find_between(self, start: string, end: string) string {
        let start_pos = self.index_of(start) ?? return empty_string;
        let val = self.slice(start_pos + start.len, self.len);
        let end_pos = val.index_of(end) ?? return val;
        return val.slice(0, end_pos);
    }

    /// Strips any of ` `, `\n`, `\t`, `\v`, `\f`, `\r` from the start and end of
    /// the string.
    #[inline]
    pub fn trim_space(self) string {
        return self.trim(" \n\t\v\f\r");
    }

    /// Strips any of the characters given in `cutset` from the start and end of
    /// the string.
    pub fn trim(self, cutset: string) string {
        if self.len < 1 or cutset.len < 1 {
            return self;
        }
        let (mut pos_left: usize, mut pos_right: usize) = (0, self.len - 1);
        let mut cs_match = true;
        while pos_left <= self.len and pos_right >= -1 and cs_match {
            cs_match = false;
            for cs in cutset.as_bytes() {
                if unsafe { self.ptr[pos_left] == cs } {
                    pos_left += 1;
                    cs_match = true;
                    break;
                }
            }
            for cs2 in cutset.as_bytes() {
                if unsafe { self.ptr[pos_right] == cs2 } {
                    pos_right -= 1;
                    cs_match = true;
                    break;
                }
            }
            if pos_left > pos_right {
                return empty_string;
            }
        }
        return self.slice(pos_left, pos_right + 1);
    }

    /// Strips any of the characters given in `cutset` from the left of the
    /// string.
    pub fn trim_left(self, cutset: string) string {
        if self.len < 1 or cutset.len < 1 {
            return self;
        }
        let mut pos: usize = 0;
        while pos < self.len : pos += 1 {
            let mut found = false;
            for cs in cutset.as_bytes() {
                if unsafe { self.ptr[pos] == cs } {
                    found = true;
                    break;
                }
            }
            if !found {
                break;
            }
        }
        return self.slice(pos, self.len);
    }

    /// Strips any of the characters given in `cutset` from the right of the
    /// string.
    pub fn trim_right(self, cutset: string) string {
        if self.len < 1 or cutset.len < 1 {
            return self;
        }
        let mut pos = self.len - 1;
        while pos >= 0 : pos -= 1 {
            let mut found = false;
            for cs in cutset.as_bytes() {
                if unsafe { self.ptr[pos] == cs } {
                    found = true;
                }
            }
            if !found {
                break;
            }
        }
        if pos < 0 {
            return empty_string;
        }
        return self.slice(pos + 1, self.len);
    }

    /// Replaces all occurences of `rep` with the string passed in `with_`.
    pub fn replace(self, rep: string, with_: string) string {
        if self.len == 0 or rep.len == 0 or rep.len > self.len {
            return self;
        } else if !self.contains(rep) {
            return self;
        }
        let mut idx: usize = 0;
        let mut idxs: [usize] = [];
        while {
            idx = self.index_after_of(rep, idx) ?? break;
            idxs.push(idx);
            idx += rep.len;
        }
        if idxs.len == 0 {
            return self;
        }
        let new_len = self.len + idxs.len * (with_.len - rep.len);
        let mut b = @as(*mut u8, internal_alloc(new_len));
        let (mut b_i: usize, mut s_idx: usize) = (0, 0);
        unsafe {
            for rep_pos in idxs {
                let mut i: usize = s_idx;
                while i < rep_pos : i += 1 {
                    b[b_i] = self.ptr[i];
                    b_i += 1;
                }
                s_idx = rep_pos + rep.len;
                i = 0;
                while i < with_.len : i += 1 {
                    b[b_i] = with_.ptr[i];
                    b_i += 1;
                }
            }
            if s_idx < self.len {
                let mut i: usize = s_idx;
                while i < self.len : i += 1 {
                    b[b_i] = self.ptr[i];
                    b_i += 1;
                }
            }
            b[new_len] = 0;
        }
        return unsafe { string.from_raw_with_len(b, new_len) };
    }

    #[inline]
    pub fn as_bytes(self) [u8] {
        return unsafe {
            Vec.from_array_no_alloc(@as(*mut u8, self.ptr), @size_of(u8), self.len)
        };
    }

    /// Splits the string to an array by any of the `delim` chars.
    /// Example:
    /// >> "first row\nsecond row".split_any(" \n") == ['first', 'row', 'second', 'row']
    /// Split a string using the chars in the delimiter string as delimiters chars.
    /// If the delimiter string is empty then `.split()` is used.
    pub fn split_any(self, delim: string) [string] {
        let (mut i: usize, mut res: [string]) = (0, []);
        // check empty source string
        if self.len > 0 {
            // if empty delimiter string using default split
            if delim.len <= 0 {
                return self.split("");
            }
            for index, ch in self.as_bytes() {
                for delim_ch in delim.as_bytes() {
                    if ch == delim_ch {
                        res.push(self[i..index]);
                        i = index + 1;
                        break;
                    }
                }
            }
            if i < self.len {
                res.push(self[i..]);
            }
        }
        return res;
    }

    /// Splits the string based on the passed `delim` substring. It returns the
    /// first nth parts. When nth == 0, return all the splits.
    /// The last returned element has the remainder of the string, even if the
    /// remainder contains more `delim` substrings.
    pub fn split(self, delim: string, nth: usize = 0) [string] {
        let (mut i: usize, mut res: [string]) = (0, []);
        switch delim.len {
            0 => {
                i = 1;
                for ch in self.as_bytes() {
                    if nth > 0 and i >= nth {
                        res.push(self[i..]);
                        break;
                    }
                    res.push(ch.to_ascii());
                    i += 1;
                }
                return res;
            },
            1 => {
                let mut start: usize = 0;
                let delim_byte = delim[0];
                while i < self.len {
                    if unsafe { self.ptr[i] == delim_byte } {
                        if nth > 0 and res.len == nth - 1 {
                            break;
                        }
                        res.push(self[start..i]);
                        start = i + delim.len;
                        i = start;
                    } else {
                        i += 1;
                    }
                }
                if nth < 1 or res.len < nth {
                    res.push(self[start..]);
                }
                return res;
            },
            else => {
                let mut start: usize = 0;
                while i <= self.len {
                    let is_delim = i + delim.len <= self.len and self[i..i + delim.len] == delim;
                    if is_delim {
                        if nth > 0 and res.len == nth - 1 {
                            break;
                        }
                        res.push(self[start..i]);
                        start = i + delim.len;
                        i = start;
                    } else {
                        i += 1;
                    }
                }
                if nth < 1 or res.len < nth {
                    res.push(self[start..]);
                }
                return res;
            }
        }
    }

    /// Splits the string by newline characters.
    pub fn split_into_lines(self) [string] {
        let mut res: [string] = [];
        if self.len == 0 {
            return res;
        }
        let (mut start: usize, mut end: usize) = (0, 0);
        let mut i: usize = 0;
        while i < self.len : i += 1 {
            if unsafe { self.ptr[i] == 10 } {
                end = if i > 0 and unsafe { self.ptr[i - 1] == 13 } { i - 1 } else { i };
                res.push(if start == end { "" } else { self[start..end] });
                start = i + 1;
            }
        }
        if start < self.len {
            res.push(self[start..]);
        }
        return res;
    }

    /// Returns an iterator that iterates over the slices of `self` that are not
    /// any of the bytes in `delimiter_bytes`.
    ///
    /// `"   abc def    ghi  ".tokenize(b' ')` will return slices for "abc", "def",
    /// "ghi", nil, in that order.
    ///
    /// If `self` is empty, the iterator will return nil.
    /// If `delimiter_bytes` does not exist in self, the iterator will return `self`,
    /// nil, in that order.
    #[inline]
    pub fn tokenize(self, delimiter_bytes: ...u8) TokenIterator {
        return TokenIterator(self, delimiter_bytes);
    }

    pub fn ==(self, rhs: Self) bool {
        if self.len != rhs.len {
            return false;
        }
        unsafe {
            if self.len > 0 {
                let last_idx = self.len - 1;
                if self.ptr[last_idx] != rhs.ptr[last_idx] {
                    return false;
                }
            }
        }
        return mem_cmp(self.ptr, rhs.ptr, rhs.len) == 0;
    }

    #[inline]
    pub fn !=(self, rhs: Self) bool {
        return !(self == rhs);
    }

    pub fn <(self, rhs: Self) bool {
        let mut i: usize = 0;
        while i < self.len : i += 1 {
            unsafe {
                if i >= rhs.len or self.ptr[i] > rhs.ptr[i] {
                    return false;
                } else if self.ptr[i] < rhs.ptr[i] {
                    return true;
                }
            }
        }
        if self.len < rhs.len {
            return true;
        }
        return false;
    }

    #[inline]
    pub fn >(self, rhs: Self) bool {
        return !(self < rhs);
    }

    #[inline]
    pub fn <=(self, rhs: Self) bool {
        return self < rhs or self == rhs;
    }

    #[inline]
    pub fn >=(self, rhs: Self) bool {
        return self > rhs or self == rhs;
    }

    /// Returns `true` if the string contains `substr`.
    pub fn contains(self, substr: string) bool {
        if substr.len == 0 {
            return true;
        }
        if let _ = self.index_of(substr) {
            return true;
        }
        return false;
    }

    /// Returns `true` if the string starts with `p`.
    pub fn starts_with(self, p: string) bool {
        if p.len > self.len {
            return false;
        }
        let mut i: usize = 0;
        while i < p.len : i += 1 {
            if unsafe { self.ptr[i] != p[i] } {
                return false;
            }
        }
        return true;
    }

    /// Returns `true` if the string ends with `p`.
    pub fn ends_with(self, p: string) bool {
        if p.len > self.len {
            return false;
        }
        let mut i: usize = 0;
        while i < p.len : i += 1 {
            if unsafe { p[i] != self.ptr[self.len - p.len + i] } {
                return false;
            }
        }
        return true;
    }

    /// Returns the number of runes contained in `self`.
    #[inline]
    pub fn runes_count(self) usize {
        return cstr_runes_count(unsafe { self.ptr }, self.len);
    }

    #[inline]
    pub fn is_empty(self) bool {
        return self.len == 0;
    }

    fn slice(self, start: usize, end: usize) Self {
        unsafe {
            if start > end or start > self.len or end > self.len {
                process_panic(
                    "string slice index out of range (range: {}..{}, len: {})", start,
                    end, self.len
                );
            }
            let len = end - start;
            if len == self.len {
                return self;
            }
            return Self(@ptr_add(self.ptr, start), len, is_ref: true);
        }
    }

    #[inline]
    fn slice_from(self, start: usize) Self {
        return self.slice(start, self.len);
    }

    pub fn clone(self) Self {
        if self.len == 0 {
            return empty_string;
        }
        let res = @as(*mut u8, internal_alloc(self.len + 1));
        unsafe {
            mem_copy(res, self.ptr, self.len);
            res[self.len] = 0;
        }
        return Self(res, self.len);
    }

    #[inline]
    pub fn hash(self) usize {
        return sum64_string(self);
    }

    #[inline]
    pub fn to_string(self) Self {
        return self;
    }

    ~Self(self) {
        if !self.is_ref {
            unsafe {
                mem_dealloc(self.ptr);
            }
        }
    }
}

pub struct TokenIterator {
    buffer: string;
    delimiter_bytes: [u8];
    mut index: usize;

    /// Returns a slice of the current token, or nil if tokenization is
    /// complete, and advances to the next token.
    pub fn next(mut self) ?string {
        let result = self.peek() ?? return nil;
        self.index += result.len;
        return result;
    }

    /// Returns a slice of the current token, or nil if tokenization is
    /// complete. Does not advance to the next token.
    pub fn peek(mut self) ?string {
        // move to beginning of token
        while self.index < self.buffer.len and self.is_split_byte(self.buffer[self.index])
            : self.index += 1 {}
        let start = self.index;
        if start == self.buffer.len {
            return nil;
        }
        // move to end of token
        let mut end = start;
        while end < self.buffer.len and !self.is_split_byte(self.buffer[end])
            : end += 1 {}
        return self.buffer[start..end];
    }

    /// Returns a slice of the remaining bytes. Does not affect iterator state.
    pub fn rest(&self) string {
        // move to beginning of token
        let mut index: usize = self.index;
        while index < self.buffer.len and self.is_split_byte(self.buffer[index])
            : index += 1 {}
        return self.buffer[index..];
    }

    /// Resets the iterator to the initial token.
    pub fn reset(mut self) {
        self.index = 0;
    }

    fn is_split_byte(&self, byte: u8) bool {
        for delimiter_byte in self.delimiter_bytes {
            if byte == delimiter_byte {
                return true;
            }
        }
        return false;
    }
}

pub struct StringFormatter {
    buf: string;
    mut i: usize;
    mut res: StringBuilder;

    fn fwidth(mut self) (bool, isize) {
        if unsafe { self.buf[self.i] != b':' } {
            return (false, @as(isize, 0));
        }
        self.i += 1;
        let start = self.i;
        let mut buf = StaticBuffer();
        while unsafe { self.buf.ptr[self.i] != b'}' } {
            buf.push(unsafe { self.buf.ptr[self.i] });
            self.i += 1;
            if self.i >= self.buf.len {
                process_panic("string.fmt(): incomplete format string (index: {})", start);
            }
        }
        return (true, buf.as_isize());
    }

    fn fmt(mut self, args: ...ToString) string {
        self.res = StringBuilder.new(self.buf.len);
        let mut args_idx: usize = 0;
        while self.i < self.buf.len : self.i += 1 {
            let b = unsafe { self.buf.ptr[self.i] };
            let b2 = if self.i + 1 < self.buf.len unsafe { self.buf.ptr[self.i + 1] } else { 0 };
            switch b {
                b'{' => {
                    if b2 == b'{' { // escaping '{'
                        self.res.write_byte(b'{');
                        self.i += 1;
                    } else if b2 == b':' or b2 == b'}' {
                        if b2 == b':' {
                            self.i += 1;
                        }
                        let (has_fwidth, fwidth) = self.fwidth();
                        let arg_idx = args_idx;
                        args_idx += 1;
                        if arg_idx >= args.len {
                            process_panic(
                                "string.fmt(): argument index out of range (argument index: {}, len: {}, index: {})",
                                arg_idx, args.len, self.i
                            );
                        }
                        let value = args[arg_idx].to_string();
                        if has_fwidth and fwidth >= 0 {
                            self.res.write_string(" ".repeat(@as(usize, fwidth) - value.len));
                        }
                        self.res.write_string(value);
                        if has_fwidth and fwidth < 0 {
                            self.res.write_string(" ".repeat(@as(usize, -fwidth) - value.len));
                        }
                        if !has_fwidth {
                            self.i += 1;
                        }
                    } else if b2.is_digit() {
                        let start = self.i;
                        self.i += 1;
                        let mut buf = StaticBuffer();
                        while unsafe {
                            self.buf.ptr[self.i] != b'}' and self.buf.ptr[self.i] != b':'
                        } {
                            buf.push(unsafe { self.buf.ptr[self.i] });
                            self.i += 1;
                            if self.i >= self.buf.len {
                                process_panic(
                                    "string.fmt(): incomplete format string (index: {})",
                                    start
                                );
                            }
                        }
                        let index = buf.as_u64();
                        if index >= args.len {
                            process_panic(
                                "string.fmt(): argument index out of range (index: {}, len: {})",
                                index, args.len
                            );
                        }
                        let (has_fwidth, fwidth) = self.fwidth();
                        let value = args[index].to_string();
                        if has_fwidth and fwidth >= 0 {
                            self.res.write_string(" ".repeat(@as(usize, fwidth) - value.len));
                        }
                        self.res.write_string(value);
                        if has_fwidth and fwidth < 0 {
                            self.res.write_string(" ".repeat(@as(usize, -fwidth) - value.len));
                        }
                    } else {
                        process_panic(
                            "string.fmt(): expecting closing `}}` in format string (index: {})",
                            self.i
                        );
                    }
                },
                b'}' => {
                    if b2 == b'}' { // escaping '}'
                        self.res.write_byte(b'}');
                        self.i += 1;
                    } else {
                        process_panic(
                            "string.fmt(): single `}}` encountered in format string (index: {})",
                            self.i
                        );
                    }
                },
                else => self.res.write_byte(b)
            }
        }
        return self.res.to_string();
    }
}
